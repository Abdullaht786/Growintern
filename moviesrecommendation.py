# -*- coding: utf-8 -*-
"""MovieScreen

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/moviescreen-3f04d2ac-54ec-456b-9091-ee5ead033dc4.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20241015/auto/storage/goog4_request%26X-Goog-Date%3D20241015T065819Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D5fcfe42f59cdb25ab65af166986c5b014562d82306d1601b7b72422be86807b8d19e627bbed949592a245605aa0115bba16c6e85b0bbe8d58f0c18beb2e189c2721ff4095389c7a1f52dd21c0290f7a37216142eb76cfc93a480e8bdc1d954492e166a0506bea355a2eb3534d134f2166f382c32b82a0dc36a06bee379b50c1cc315f73e5ac194e2c08b1349fead34711b9ebc50c178c2ce5fe9dfc41dc67ea9296d9db2df44cd3837132037a51652f294e40f4ed9e60eeda81684f63acf55e78b7838aa215c30b476643c597205eda1357703b228c26d9740b03a41c3b25e64e83cdb18f2c4f4ef71af7c5fe20b4912cd3ff8793e7b0cdf5b877936c9d84e52
"""

import numpy as np # linear algebra
import pandas as pd # data processing
import matplotlib.pyplot as plt

paths = {}

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))
        paths[filename] = os.path.join(dirname, filename)

from sklearn.preprocessing import MultiLabelBinarizer # one-hot encoding
from sklearn.neighbors import NearestNeighbors # KNN

ratings = pd.read_csv(paths["ratings.csv"])
movies = pd.read_csv(paths["movies.csv"])

print("Datasets loaded")

print(movies.shape)
movies.head()

print(ratings.shape)
ratings.head()

unique_users = len(ratings["userId"].unique())
movies_count = len(movies["movieId"].unique())

print(unique_users, movies_count)

ratings['rating'].value_counts().plot(kind='bar')

# combine data
merged_data = pd.merge(ratings, movies, on='movieId')

print(merged_data.shape)
merged_data.head()

data = movies

# one-hot encoding
mlb = MultiLabelBinarizer()
genre_encoded = mlb.fit_transform(data['genres'].str.split('|'))
genre_df = pd.DataFrame(genre_encoded, columns=mlb.classes_)

data = pd.concat([data, genre_df], axis=1)
data.head()

"""# Model 1: KNN Based Genre Similarity
This model employs a K-Nearest Neighbors (KNN) algorithm to recommend movies based solely on their genres. By creating a feature matrix that includes only the movie titles and their associated genres, it simplifies the data to focus exclusively on genre similarity. When a user inputs a movie, the model identifies the K nearest movies in the feature space based on their genre composition. This approach allows for quick recommendations of films that are closely aligned in genre, providing users with relevant suggestions that cater to their specific tastes without considering other attributes such as ratings or user interactions.
"""

features = data.drop(columns=[
#     'userId', 'rating', 'timestamp',
    'genres', 'title', 'movieId'])

features.head()

knn_model_genres = NearestNeighbors(n_neighbors=5, algorithm='auto')
knn_model_genres.fit(features)

def recommend_similar_movies_model1(movie_title, *, n=5, model=knn_model_genres, data=movies, features=features):
    movie_idx = data[data['title'] == movie_title].index[0]
    distances, indices = model.kneighbors(features.iloc[movie_idx, :].values.reshape(1, -1), n_neighbors=n)
    recommended_movies = data.iloc[indices.flatten()]
    return recommended_movies

recommend_similar_movies_model1("Toy Story (1995)")

"""# Model 2: User-Item Matrix with Cosine Similarity
This model utilizes a user-item matrix combined with cosine similarity to enhance movie recommendations by incorporating user ratings. By constructing a matrix where rows represent movies and columns represent users, the model captures the relationships between users and their rated movies. It calculates cosine similarity between movies based on user ratings, allowing it to identify films that are similar in terms of user preferences. When a user inputs a movie, the model retrieves other movies that are most similar according to the cosine similarity measure, resulting in personalized recommendations that reflect the tastes and preferences of users who rated similar movies. This approach provides a more nuanced recommendation system, considering both the content of the movies and user interactions.
"""

# training on 5% of all data for performance reasons
filtered_data = merged_data.head(merged_data.shape[0] // 20)

user_item_matrix = filtered_data.pivot_table(index='movieId', columns='userId', values='rating').fillna(0)
print(user_item_matrix.shape)

mean_user_rating = np.mean(np.array(user_item_matrix), axis=1).reshape(-1, 1)

normalized_matrix = user_item_matrix - mean_user_rating

knn_model_matrix = NearestNeighbors(n_neighbors=5, metric='cosine', algorithm='auto')
knn_model_matrix.fit(normalized_matrix)

def recommend_similar_movies_model2(movie_title, n=5, model=knn_model_matrix, data=filtered_data, features=normalized_matrix):
    movie_idx = data[data['title'] == movie_title].index[0]
    distances, indices = model.kneighbors(features.iloc[movie_idx].values.reshape(1, -1), n_neighbors=n)
    recommended_movies = data.iloc[indices.flatten()]
    return recommended_movies

recommend_similar_movies_model2("Toy Story (1995)")